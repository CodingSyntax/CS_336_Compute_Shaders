#version 430

//Workgroup size
layout(local_size_x = 64) in;

// layout(rgba32f, binding = 0) uniform image2D colorBuffer;

layout(std430, binding = 1) buffer particleApi
{
    // Should be in the format {posX, posY, mass}
    float particles[][3];
} particleBuffer;

layout(std430, binding = 2) buffer forceApi
{
    // Should be in the format {accX, accY}
    float force[][2];
} forceBuffer;


const float G = 10;

void main() {
    // ivec2 pixelPos = ivec2(gl_GlobalInvocationID.xy);
    // ivec2 screenSize = imageSize(colorBuffer);
    // if (pixelPos.x >= screenSize.x || pixelPos.y >= screenSize.y) return;
    
    // float apectRatio = float(screenSize.y)/screenSize.x;
    
    // DO the math thing
    float distx, disty, A, netAx, netAy, dir;
    int size = particleBuffer.particles.length();
    uint i = gl_GlobalInvocationID.x;
    netAx = 0;
    netAy = 0;
    for(uint j = i + 1; j < size; ++j) {

        distx = particleBuffer.particles[j][0] - particleBuffer.particles[i][0]; 
        disty = particleBuffer.particles[j][1] - particleBuffer.particles[i][1];
        
        float dist = sqrt(distx * distx + disty * disty);
        float distu = (distx * distx + disty * disty);
        if (dist <= 0) continue; //Prevents division by 0
        
        //Force = mass * acc
        // 
        
        // A =  / (distx * distx + disty * disty);
        // netAx += A * cos(dir);
        float Ax = (distx / distu) * abs(particleBuffer.particles[j][2]);
        float Ay = (disty / distu) * abs(particleBuffer.particles[j][2]);
        // netAy += A * sin(dir);
        
        float c = (particleBuffer.particles[i][2]) * (particleBuffer.particles[j][2]);
        float m = -1;
        if (c < 0) m = 1;
        
        float forceX = m * abs(particleBuffer.particles[i][2]) * Ax * G;
        float forceY = m * abs(particleBuffer.particles[i][2]) * Ay * G;
        forceBuffer.force[i][0] += forceX;
        forceBuffer.force[i][1] += forceY;
        forceBuffer.force[j][0] -= forceX;
        forceBuffer.force[j][1] -= forceY;
    }
    //Write
    // accelBuffer.accel[i][0] = netAx * G;
    // accelBuffer.accel[i][1] = netAy * G;
    
    // vec3 color = vec3(0.0);
    
    //write
    // imageStore(colorBuffer, pixelPos, vec4(color, 1.0));
}
#end