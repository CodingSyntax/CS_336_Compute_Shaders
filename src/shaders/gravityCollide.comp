#version 430

#define posX(i) particleBuffer.particles[i][0]
#define posY(i) particleBuffer.particles[i][1]
#define mass(i) particleBuffer.particles[i][2]
#define velX(i) particleBuffer.particles[i][3]
#define velY(i) particleBuffer.particles[i][4]
#define forceX(i) forceBuffer.force[i][0]
#define forceY(i) forceBuffer.force[i][1]

//Workgroup size
layout(local_size_x = 64) in;

// layout(rgba32f, binding = 0) uniform image2D colorBuffer;

layout(std430, binding = 1) buffer particleApi
{
    // Should be in the format {posX, posY, mass, velX, velY}
    float particles[][5];
} particleBuffer;

layout(std430, binding = 2) buffer forcecApi
{
    // Should be in the format {forceX, forceY}
    float force[][2];
} forceBuffer;


const float G = 10;
const float elasticity = 0.25;
const float TIMESTEP = 0.02;

void main() {
    // ivec2 pixelPos = ivec2(gl_GlobalInvocationID.xy);
    // ivec2 screenSize = imageSize(colorBuffer);
    // if (pixelPos.x >= screenSize.x || pixelPos.y >= screenSize.y) return;
    
    // float apectRatio = float(screenSize.y)/screenSize.x;
    
    // DO the math thing
    float distx, disty, A, dir, dist;
    int size = particleBuffer.particles.length();
    uint i = gl_GlobalInvocationID.x;
    
    for(uint j = i + 1; j < size; ++j) {

        distx = posX(j) - posX(i); 
        disty = posY(j) - posY(i);
        
        float udist = distx * distx + disty * disty;
        dist = sqrt(udist);
        
        if (dist <= 1) continue; //Prevents division by 0
        dir = atan(disty, distx);
        
        //Force = mass * acc
        // 

        A = mass(j) / udist;
        
        float forceM = mass(i) * A * G;
        
        float forceX = forceM * cos(dir);
        float forceY = forceM * sin(dir);
        forceX(i) += forceX;
        forceY(i) += forceY;
        forceX(j) -= forceX;
        forceY(j) -= forceY;
        
        
        //collision stuff
        // float collisionNormalX = distx / dist;
        // float collisionNormalY = disty / dist;
        
        // float relativeSpeedX = velX(j) - velX(i);
        // float relativeSpeedY = velY(j) - velY(i);
        // float constraintSpeed = collisionNormalX * relativeSpeedX + collisionNormalY * relativeSpeedY;
        // float constraintValue = dist - 10;
        
        // if (constraintValue < 0 && constraintSpeed < 0) {
        //     float sumMass = mass(i) - mass(j);
        //     float reducedMass = 1.0 / (1.0 / mass(i) + 1.0 / mass(j));
            
        //     float offsetX = constraintValue * collisionNormalX;
        //     float offsetY = constraintValue * collisionNormalY;
            
        //     float nMassJ = mass(j) / sumMass;
        //     float nMassI = mass(i) / sumMass;
            
        //     posX(i) += offsetX * nMassJ;
        //     posY(i) += offsetY * nMassJ;
        //     posX(j) -= offsetX * nMassI;
        //     posY(j) -= offsetY * nMassI;
            
        //     float m = (-constraintSpeed * (1.0 + elasticity)) * reducedMass;
        //     float impX = collisionNormalX * m;
        //     float impY = collisionNormalY * m;
            
        //     velX(i) -= impX / mass(i);
        //     velY(i) -= impY / mass(i);
        //     velX(j) += impX / mass(j);
        //     velY(j) += impY / mass(j);
        // }
    }
    
    //set pos
    velX(i) += (forceX(i) * TIMESTEP) / mass(i);
    velY(i) += (forceY(i) * TIMESTEP) / mass(i);
    posX(i) += velX(i) * TIMESTEP;
    posY(i) += velY(i) * TIMESTEP;
}
#end